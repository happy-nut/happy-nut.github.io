# Hash map

HashMap 은 일반적으로 해싱된 키를 기반으로 O(1) 으로 값을 조회를 할 수 있다고 알려져 있다.
기본적으로 배열(bucket array) 자료구조를 떠올리면 되는데, 해시함수는 Capacity - 1 으로 mod 했을 때의 배열 인덱스로 들어가게끔 해시코드를 생성함.

이 때 capacity 를 2의 배수로 강제하면 capacity - 1 로 mod 하는 것을 단순 and 연산으로 치환 가능하다.
그런데 당연히 해시함수 구현에 따라 같은 배열 인덱스를 가리키는 경우가 있음.

이렇게 되면 체이닝(여러 엔트리를 한 배열 인덱스에 묶음)이 일어나고, 한 배열 안에서 해시 값이 완전히 일치하면서 key.equals() 가 true인 인덱스로 엔트리를 찾음 = O(n).

체이닝이 너무 많이 되면 성능이 떨어지니 체이닝 사이즈가 8 이상이 되면 레드 블랙 트리로 체이닝 트리를 만들어 조회 성능을 O(log(n))으로 최적화 함.
배열 크기가 작으면 해시 충돌이 너무 많이 생겨 체이닝 사이즈가 늘어날 것. 그래서 load factor 를 두어 capacity 를 2의 배수로 늘림.
java에서 load factor 는 0.75이고, 이 값이 넘어가서 capacity가 resize되면 체이닝되었던 트리들도 rebalancing 이 일어남.

따라서 HashMap의 조회 성능은 항상 O(1)이라고 말할 수는 없으며, 평균적으로 O(1)이다가 더 맞는 표현임.
