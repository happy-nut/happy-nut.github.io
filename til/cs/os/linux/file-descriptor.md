# File Descriptor in Linux

리눅스 계열의 시스템에서는 모든 입출력(IO)은 파일로 취급하는 철학이 있다.
따라서 일반적인 파일 읽고 쓰기 외에도, 파이프, 장치 제어, 소켓 등은 모두 파일로 처리되고, 이 때 처리되는 파일의 핸들이 바로 FD(File Descriptor)이다.

## 특징

fd는 0 이상의 정수 값으로 표현된다. 그냥 단순히 정수 값이 어떻게 장치 제어까지 하게 되느냐하는 궁금증이 떠오르는데, 이것은 리눅스 커널의 리소스와 파일 디스크립터 사이의
매핑 정보를 가지는 fd table 이 프로세스마다 할당이 되기 때문이다. 즉, fd는 IO와 관련된 커널 리소스의 추상화된 인터페이스라고 보면 된다.

fd table 안에는 0, 1, 2, ... 의 fd 값이 배열로 저장되어 있고, 해당 인덱스의 포인터가 가리키는 값은 파일의 주소가 된다.
그 중 0, 1, 2 는 각각 stdin, stdout, stderr 로 예약되어 있다.

또한, fd 는 무한정 생성할 수 없다. 프로세스 별로 할당할 수 있는 fd에 제한을 두기 때문이다.
다음 명령어를 통해 현재 세션(쉘의 프로세스)의 파일 디스크립터 제한을 확인할 수 있다. 

```sh
ulimit -n
```

## 자식 프로세스에서의 fd

프로세스마다 fd table 을 가지게 된다고 했는데, fork()를 통해 자식 프로세스를 생성한다면 
자식 프로세스로 fd table 이 그대로 복사된다. 따라서 부모가 열어놓은 fd 들을 자식 프로세스에서 그대로 사용할 수 있다.

다만, 부모에서 close() 를 통해 fd를 닫게 되더라도, 참조 자체는 카운터로 관리되기 때문에 여전히 자식에서 사용하더라도 문게가 되지 않는다.
카운터가 1 이상이라면 실제론 정리가 되지 않기 때문이다.

다만 이런 경우 버그가 발생하기 쉽고, fd 또한 leak 이 생길 수 있으므로 잘 관리할 수 있어야 한다.

## 모니터링

톰캣으로 커넥션 풀을 두어 제한을 준다고 하더라도 fd 제한에 도달할 수 있다. 서버 안으로 들어오는 요청이 아니라, 서버에서 외부로 나가는 요청이 많아질 수 있기 때문이다.
그렇게 되면 아래와 같은 에러를 마주할 수 있게 되므로, fd는 모니터링해야하는 핵심 지표 중 하나다. 

```java
java.net.SocketException: Too many open files
```

